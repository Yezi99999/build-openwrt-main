#========================================================================================================================
# 🛠️ OpenWrt 智能编译工作流
# 功能: 接收Web界面传递的配置参数，智能编译指定设备和插件的固件
#========================================================================================================================

name: 🛠️ 智能编译固件

on:
  # Web界面触发（推荐方式）
  repository_dispatch:
    types: [web_build]
  
  # 手动触发（备用方式）
  workflow_dispatch:
    inputs:
      source_branch:
        description: '源码分支'
        required: true
        default: 'lede-master'
        type: choice
        options:
          - lede-master
          - openwrt-main
          - immortalwrt-master
          - Lienol-master
      target_device:
        description: '目标设备'
        required: true
        default: 'x86_64'
        type: choice
        options:
          - x86_64
          - xiaomi_4a_gigabit
          - newifi_d2
          - rpi_4b
          - nanopi_r2s
          - k2p
          - ac68u
          - r7800
          - wrt3200acm
      plugins_list:
        description: '插件列表（用逗号分隔）'
        required: false
        default: ''
        type: string
      build_description:
        description: '编译描述'
        required: false
        default: '手动触发编译'
        type: string

# 环境变量
env:
  TZ: Asia/Shanghai
  UPLOAD_BIN_DIR: false
  UPLOAD_FIRMWARE: true
  UPLOAD_RELEASE: true
  UPLOAD_WETRANSFER: false
  UPLOAD_ANON: false
  CACHE_TOOLCHAIN: true

jobs:
  # 预处理任务
  prepare:
    runs-on: ubuntu-24.04
    name: 📋 准备编译环境
    outputs:
      source_branch: ${{ steps.config.outputs.source_branch }}
      target_device: ${{ steps.config.outputs.target_device }}
      plugins_list: ${{ steps.config.outputs.plugins_list }}
      build_description: ${{ steps.config.outputs.build_description }}
      repo_url: ${{ steps.config.outputs.repo_url }}
      repo_branch: ${{ steps.config.outputs.repo_branch }}
      source_name: ${{ steps.config.outputs.source_name }}
      device_name: ${{ steps.config.outputs.device_name }}
      device_profile: ${{ steps.config.outputs.device_profile }}
      device_target: ${{ steps.config.outputs.device_target }}
      build_tag: ${{ steps.config.outputs.build_tag }}
      cache_key: ${{ steps.config.outputs.cache_key }}
      config_file: ${{ steps.config.outputs.config_file }}
      feeds_conf: ${{ steps.config.outputs.feeds_conf }}
      diy_p1_sh: ${{ steps.config.outputs.diy_p1_sh }}
      diy_p2_sh: ${{ steps.config.outputs.diy_p2_sh }}

    steps:
      - name: 🚀 检出代码
        uses: actions/checkout@v4

      - name: 🔧 解析编译配置
        id: config
        run: |
          echo "📋 解析编译配置..."
          
          # 根据触发方式获取配置参数
          if [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
            echo "🌐 检测到Web界面触发的编译请求"
            SOURCE_BRANCH="${{ github.event.client_payload.source_branch }}"
            TARGET_DEVICE="${{ github.event.client_payload.target_device }}"
            PLUGINS_LIST="${{ github.event.client_payload.plugins }}"
            BUILD_DESC="Web界面编译"
          else
            echo "🖱️ 检测到手动触发的编译请求"
            SOURCE_BRANCH="${{ github.event.inputs.source_branch }}"
            TARGET_DEVICE="${{ github.event.inputs.target_device }}"
            PLUGINS_LIST="${{ github.event.inputs.plugins_list }}"
            BUILD_DESC="${{ github.event.inputs.build_description }}"
          fi
          
          # 设置默认值
          SOURCE_BRANCH=${SOURCE_BRANCH:-"lede-master"}
          TARGET_DEVICE=${TARGET_DEVICE:-"x86_64"}
          PLUGINS_LIST=${PLUGINS_LIST:-""}
          BUILD_DESC=${BUILD_DESC:-"智能编译"}
          
          echo "📋 编译配置信息:"
          echo "  源码分支: $SOURCE_BRANCH"
          echo "  目标设备: $TARGET_DEVICE"
          echo "  插件列表: $PLUGINS_LIST"
          echo "  编译描述: $BUILD_DESC"
          
          # 根据源码分支设置仓库信息和配置文件路径
          case $SOURCE_BRANCH in
            "openwrt-main")
              REPO_URL="https://github.com/openwrt/openwrt"
              REPO_BRANCH="main"
              SOURCE_NAME="OpenWrt官方"
              FEEDS_CONF="config/openwrt-main/feeds.conf.default"
              CONFIG_FILE="config/openwrt-main/config"
              DIY_P1_SH="config/openwrt-main/diy-part1.sh"
              DIY_P2_SH="config/openwrt-main/diy-part2.sh"
              ;;
            "lede-master")
              REPO_URL="https://github.com/coolsnowwolf/lede"
              REPO_BRANCH="master"
              SOURCE_NAME="Lean's LEDE"
              FEEDS_CONF="config/lede-master/feeds.conf.default"
              CONFIG_FILE="config/lede-master/config"
              DIY_P1_SH="config/lede-master/diy-part1.sh"
              DIY_P2_SH="config/lede-master/diy-part2.sh"
              ;;
            "immortalwrt-master")
              REPO_URL="https://github.com/immortalwrt/immortalwrt"
              REPO_BRANCH="master"
              SOURCE_NAME="ImmortalWrt"
              FEEDS_CONF="config/immortalwrt-master/feeds.conf.default"
              CONFIG_FILE="config/immortalwrt-master/config"
              DIY_P1_SH="config/immortalwrt-master/diy-part1.sh"
              DIY_P2_SH="config/immortalwrt-master/diy-part2.sh"
              ;;
            "Lienol-master")
              REPO_URL="https://github.com/Lienol/openwrt"
              REPO_BRANCH="master"
              SOURCE_NAME="Lienol's OpenWrt"
              FEEDS_CONF="config/Lienol-master/feeds.conf.default"
              CONFIG_FILE="config/Lienol-master/config"
              DIY_P1_SH="config/Lienol-master/diy-part1.sh"
              DIY_P2_SH="config/Lienol-master/diy-part2.sh"
              ;;
            *)
              echo "❌ 不支持的源码分支: $SOURCE_BRANCH"
              exit 1
              ;;
          esac
          
          # 根据目标设备设置设备信息
          case $TARGET_DEVICE in
            "x86_64")
              DEVICE_NAME="X86_64虚拟机"
              DEVICE_PROFILE="generic"
              DEVICE_TARGET="x86/64"
              CONFIG_FILE="${CONFIG_FILE}_x86_64"
              ;;
            "xiaomi_4a_gigabit")
              DEVICE_NAME="小米路由器4A千兆版"
              DEVICE_PROFILE="xiaomi_mi-router-4a-gigabit"
              DEVICE_TARGET="ramips/mt7621"
              CONFIG_FILE="${CONFIG_FILE}_mi4a"
              ;;
            "newifi_d2")
              DEVICE_NAME="新路由3"
              DEVICE_PROFILE="d-team_newifi-d2"
              DEVICE_TARGET="ramips/mt7621"
              CONFIG_FILE="${CONFIG_FILE}_d2"
              ;;
            "rpi_4b")
              DEVICE_NAME="树莓派4B"
              DEVICE_PROFILE="rpi-4"
              DEVICE_TARGET="bcm27xx/bcm2711"
              CONFIG_FILE="${CONFIG_FILE}_rpi4"
              ;;
            "nanopi_r2s")
              DEVICE_NAME="NanoPi R2S"
              DEVICE_PROFILE="friendlyarm_nanopi-r2s"
              DEVICE_TARGET="rockchip/armv8"
              CONFIG_FILE="${CONFIG_FILE}_r2s"
              ;;
            "k2p")
              DEVICE_NAME="斐讯K2P"
              DEVICE_PROFILE="phicomm_k2p"
              DEVICE_TARGET="ramips/mt7621"
              CONFIG_FILE="${CONFIG_FILE}_k2p"
              ;;
            "ac68u")
              DEVICE_NAME="华硕AC68U"
              DEVICE_PROFILE="asus_rt-ac68u"
              DEVICE_TARGET="bcm53xx/generic"
              CONFIG_FILE="${CONFIG_FILE}_ac68u"
              ;;
            "r7800")
              DEVICE_NAME="网件R7800"
              DEVICE_PROFILE="netgear_r7800"
              DEVICE_TARGET="ipq806x/generic"
              CONFIG_FILE="${CONFIG_FILE}_r7800"
              ;;
            "wrt3200acm")
              DEVICE_NAME="领势WRT3200ACM"
              DEVICE_PROFILE="linksys_wrt3200acm"
              DEVICE_TARGET="mvebu/cortexa9"
              CONFIG_FILE="${CONFIG_FILE}_wrt3200acm"
              ;;
            *)
              echo "❌ 不支持的目标设备: $TARGET_DEVICE"
              exit 1
              ;;
          esac
          
          # 生成编译标签
          BUILD_TAG="${SOURCE_BRANCH}_${TARGET_DEVICE}_$(date +%Y%m%d_%H%M%S)"
          CACHE_KEY="${SOURCE_BRANCH}_${TARGET_DEVICE}_cache"
          
          # 输出配置信息
          echo "source_branch=$SOURCE_BRANCH" >> $GITHUB_OUTPUT
          echo "target_device=$TARGET_DEVICE" >> $GITHUB_OUTPUT
          echo "plugins_list=$PLUGINS_LIST" >> $GITHUB_OUTPUT
          echo "build_description=$BUILD_DESC" >> $GITHUB_OUTPUT
          echo "repo_url=$REPO_URL" >> $GITHUB_OUTPUT
          echo "repo_branch=$REPO_BRANCH" >> $GITHUB_OUTPUT
          echo "source_name=$SOURCE_NAME" >> $GITHUB_OUTPUT
          echo "device_name=$DEVICE_NAME" >> $GITHUB_OUTPUT
          echo "device_profile=$DEVICE_PROFILE" >> $GITHUB_OUTPUT
          echo "device_target=$DEVICE_TARGET" >> $GITHUB_OUTPUT
          echo "build_tag=$BUILD_TAG" >> $GITHUB_OUTPUT
          echo "cache_key=$CACHE_KEY" >> $GITHUB_OUTPUT
          echo "config_file=$CONFIG_FILE" >> $GITHUB_OUTPUT
          echo "feeds_conf=$FEEDS_CONF" >> $GITHUB_OUTPUT
          echo "diy_p1_sh=$DIY_P1_SH" >> $GITHUB_OUTPUT
          echo "diy_p2_sh=$DIY_P2_SH" >> $GITHUB_OUTPUT

      - name: 🔍 检测插件冲突
        if: needs.prepare.outputs.plugins_list != ''
        run: |
          echo "🔍 检测插件冲突..."
          PLUGINS="${{ needs.prepare.outputs.plugins_list }}"
          
          # 定义插件冲突规则
          declare -A conflicts=(
            ["luci-app-ssr-plus,luci-app-passwall"]="SSR Plus+和PassWall功能重复"
            ["luci-app-ssr-plus,luci-app-openclash"]="SSR Plus+和OpenClash可能冲突"
            ["luci-app-passwall,luci-app-openclash"]="PassWall和OpenClash可能冲突"
            ["luci-app-adguardhome,luci-app-adblock"]="AdGuard Home和AdBlock功能重复"
            ["luci-app-unblockmusic,luci-app-unblockneteasemusic"]="解锁网易云音乐插件重复"
          )
          
          # 检查冲突
          HAS_CONFLICT=false
          for conflict_pair in "${!conflicts[@]}"; do
            IFS=',' read -ra conflict_plugins <<< "$conflict_pair"
            FOUND_COUNT=0
            
            for plugin in "${conflict_plugins[@]}"; do
              if [[ ",$PLUGINS," == *",$plugin,"* ]]; then
                ((FOUND_COUNT++))
              fi
            done
            
            if [ $FOUND_COUNT -gt 1 ]; then
              echo "⚠️ 检测到插件冲突: ${conflicts[$conflict_pair]}"
              HAS_CONFLICT=true
            fi
          done
          
          if [ "$HAS_CONFLICT" = true ]; then
            echo "⚠️ 检测到插件冲突，编译可能失败，建议调整插件选择"
          else
            echo "✅ 插件冲突检测通过"
          fi

      - name: 📊 生成编译报告
        run: |
          echo "# 📊 OpenWrt智能编译报告" > build_report.md
          echo "" >> build_report.md
          echo "## 📋 编译配置" >> build_report.md
          echo "- **源码**: ${{ needs.prepare.outputs.source_name }} (${{ needs.prepare.outputs.source_branch }})" >> build_report.md
          echo "- **设备**: ${{ needs.prepare.outputs.device_name }} (${{ needs.prepare.outputs.target_device }})" >> build_report.md
          echo "- **架构**: ${{ needs.prepare.outputs.device_target }}" >> build_report.md
          echo "- **描述**: ${{ needs.prepare.outputs.build_description }}" >> build_report.md
          echo "- **时间**: $(date '+%Y-%m-%d %H:%M:%S')" >> build_report.md
          echo "" >> build_report.md
          
          if [ -n "${{ needs.prepare.outputs.plugins_list }}" ]; then
            echo "## 🔧 选中的插件" >> build_report.md
            IFS=',' read -ra PLUGINS <<< "${{ needs.prepare.outputs.plugins_list }}"
            for plugin in "${PLUGINS[@]}"; do
              echo "- $plugin" >> build_report.md
            done
          else
            echo "## 🔧 插件" >> build_report.md
            echo "使用默认插件配置" >> build_report.md
          fi

  # 主编译任务
  build:
    runs-on: ubuntu-24.04
    needs: prepare
    name: 🛠️ 编译 ${{ needs.prepare.outputs.device_name }}
    
    steps:
      - name: 🚀 检出代码
        uses: actions/checkout@v4

      - name: 💾 恢复缓存
        if: env.CACHE_TOOLCHAIN == 'true'
        uses: actions/cache@v4
        with:
          path: |
            openwrt/staging_dir/host*
            openwrt/staging_dir/tool*
            openwrt/build_dir/host*
            openwrt/build_dir/tool*
          key: ${{ needs.prepare.outputs.cache_key }}_${{ hashFiles('**/feeds.conf.default') }}
          restore-keys: |
            ${{ needs.prepare.outputs.cache_key }}_

      - name: 🔧 初始化编译环境
        id: init
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          echo "🔧 开始初始化编译环境..."
          
          # 释放磁盘空间
          echo "💾 释放磁盘空间..."
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /opt/ghc
          sudo rm -rf /usr/local/.ghcup
          sudo rm -rf /usr/share/swift
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          sudo rm -rf /usr/local/share/boost
          sudo rm -rf "$AGENT_TOOLSDIRECTORY"
          
          # 更新系统包
          echo "📦 更新系统包..."
          sudo -E apt-get -qq update
          
          # 安装编译依赖
          echo "📦 安装编译依赖..."
          sudo -E apt-get -qq install -y \
            ack antlr3 asciidoc autoconf automake autopoint binutils bison build-essential \
            bzip2 ccache clang cmake cpio curl device-tree-compiler ecj fastjar flex gawk \
            gettext gcc-multilib g++-multilib git gnutls-dev gperf haveged help2man intltool \
            lib32gcc-s1 libc6-dev-i386 libelf-dev libglib2.0-dev libgmp3-dev libltdl-dev \
            libmpc-dev libmpfr-dev libncurses5-dev libncursesw5 libncursesw5-dev libpython3-dev \
            libreadline-dev libssl-dev libtool lld llvm lrzsz mkisofs msmtp nano ninja-build \
            p7zip p7zip-full patch pkgconf python2.7 python3 python3-pip python3-ply \
            python3-docutils python3-pyelftools qemu-utils re2c rsync scons squashfs-tools \
            subversion swig texinfo uglifyjs upx-ucl unzip vim wget xmlto xxd zlib1g-dev
          
          # 清理不需要的包
          echo "🧹 清理系统..."
          sudo -E apt-get -qq autoremove --purge
          sudo -E apt-get -qq autoclean
          sudo -E apt-get -qq clean
          
          # 创建工作目录
          echo "📁 创建工作目录..."
          sudo mkdir -p /workdir
          sudo chown $USER:$GROUPS /workdir
          
          echo "status=success" >> $GITHUB_OUTPUT
          echo "✅ 编译环境初始化完成"

      - name: 📦 克隆源码
        id: codes
        working-directory: /workdir
        if: steps.init.outputs.status == 'success' && !cancelled()
        run: |
          echo "📦 开始克隆源码..."
          echo "  仓库: ${{ needs.prepare.outputs.repo_url }}"
          echo "  分支: ${{ needs.prepare.outputs.repo_branch }}"
          
          # 克隆源码
          git clone -q --single-branch --depth=1 --branch=${{ needs.prepare.outputs.repo_branch }} ${{ needs.prepare.outputs.repo_url }} openwrt
          ln -sf /workdir/openwrt $GITHUB_WORKSPACE/openwrt
          
          echo "status=success" >> $GITHUB_OUTPUT
          echo "✅ 源码克隆完成"

      - name: 🔧 加载自定义feeds
        run: |
          echo "🔧 配置自定义feeds..."
          
          # 如果存在自定义feeds配置
          if [ -f "${{ needs.prepare.outputs.feeds_conf }}" ]; then
            cp -f ${{ needs.prepare.outputs.feeds_conf }} openwrt/feeds.conf.default
            echo "✅ 已加载自定义feeds配置"
          fi
          
          # 执行自定义脚本1
          if [ -f "${{ needs.prepare.outputs.diy_p1_sh }}" ]; then
            chmod +x ${{ needs.prepare.outputs.diy_p1_sh }}
            cd openwrt
            $GITHUB_WORKSPACE/${{ needs.prepare.outputs.diy_p1_sh }}
            cd ..
            echo "✅ 已执行自定义脚本1"
          fi

      - name: 📥 更新feeds
        run: |
          cd openwrt
          echo "📥 更新feeds..."
          ./scripts/feeds update -a
          echo "✅ Feeds更新完成"

      - name: 📦 安装feeds
        run: |
          cd openwrt
          echo "📦 安装feeds..."
          ./scripts/feeds install -a
          echo "✅ Feeds安装完成"

      - name: 🔧 加载自定义配置
        run: |
          echo "🔧 加载自定义配置..."
          
          # 加载基础配置文件
          if [ -f "${{ needs.prepare.outputs.config_file }}" ]; then
            cp -f ${{ needs.prepare.outputs.config_file }} openwrt/.config
            echo "✅ 已加载设备基础配置"
          else
            echo "⚠️ 未找到设备配置文件，使用默认配置"
            cd openwrt
            make defconfig
            cd ..
          fi
          
          # 根据选择的插件动态修改配置
          if [ -n "${{ needs.prepare.outputs.plugins_list }}" ]; then
            echo "🔧 配置选中的插件..."
            cd openwrt
            
            # 先禁用所有可选插件
            sed -i 's/CONFIG_PACKAGE_luci-app-.*=y/# CONFIG_PACKAGE_luci-app-.*=y/g' .config
            
            # 启用选中的插件
            IFS=',' read -ra PLUGINS <<< "${{ needs.prepare.outputs.plugins_list }}"
            for plugin in "${PLUGINS[@]}"; do
              echo "  启用插件: $plugin"
              echo "CONFIG_PACKAGE_$plugin=y" >> .config
              
              # 处理插件依赖
              case $plugin in
                "luci-app-ssr-plus")
                  echo "CONFIG_PACKAGE_shadowsocksr-libev-ssr-check=y" >> .config
                  echo "CONFIG_PACKAGE_shadowsocksr-libev-ssr-local=y" >> .config
                  echo "CONFIG_PACKAGE_shadowsocksr-libev-ssr-redir=y" >> .config
                  ;;
                "luci-app-passwall")
                  echo "CONFIG_PACKAGE_chinadns-ng=y" >> .config
                  echo "CONFIG_PACKAGE_haproxy=y" >> .config
                  echo "CONFIG_PACKAGE_hysteria=y" >> .config
                  ;;
                "luci-app-openclash")
                  echo "CONFIG_PACKAGE_kmod-tun=y" >> .config
                  ;;
                "luci-app-dockerman")
                  echo "CONFIG_PACKAGE_docker-ce=y" >> .config
                  echo "CONFIG_PACKAGE_docker-compose=y" >> .config
                  echo "CONFIG_PACKAGE_dockerd=y" >> .config
                  ;;
              esac
            done
            
            cd ..
          fi
          
          # 执行自定义脚本2
          if [ -f "${{ needs.prepare.outputs.diy_p2_sh }}" ]; then
            chmod +x ${{ needs.prepare.outputs.diy_p2_sh }}
            cd openwrt
            $GITHUB_WORKSPACE/${{ needs.prepare.outputs.diy_p2_sh }}
            cd ..
            echo "✅ 已执行自定义脚本2"
          fi

      - name: 📥 下载编译包
        id: package
        run: |
          cd openwrt
          echo "📥 下载编译所需的包..."
          make defconfig
          make download -j8
          find dl -size -1024c -exec ls -l {} \;
          find dl -size -1024c -exec rm -f {} \;
          echo "✅ 包下载完成"

      - name: 🛠️ 开始编译固件
        id: compile
        run: |
          cd openwrt
          echo "🛠️ 开始编译固件..."
          echo "  设备: ${{ needs.prepare.outputs.device_name }}"
          echo "  架构: ${{ needs.prepare.outputs.device_target }}"
          echo -e "$(nproc) 个线程编译"
          
          # 开始编译
          make -j$(nproc) || make -j1 || make -j1 V=s
          
          echo "status=success" >> $GITHUB_OUTPUT
          echo "✅ 固件编译完成"

      - name: 📊 检查磁盘使用
        if: (!cancelled())
        run: |
          echo "📊 编译后磁盘使用情况:"
          df -hT

      - name: 📦 整理固件文件
        id: organize
        if: steps.compile.outputs.status == 'success' && !cancelled()
        run: |
          echo "📦 整理固件文件..."
          cd openwrt/bin/targets/*/*
          
          # 删除不需要的文件
          rm -rf packages
          rm -f *.buildinfo
          rm -f *.manifest
          rm -f *.seed
          rm -f sha256sums
          
          # 重命名固件文件
          for file in openwrt-*; do
            if [ -f "$file" ]; then
              new_name="${{ needs.prepare.outputs.build_tag }}_${file#openwrt-}"
              mv "$file" "$new_name"
              echo "  $file -> $new_name"
            fi
          done
          
          # 计算固件大小
          FIRMWARE_SIZE=$(ls -lh *.img.gz 2>/dev/null | awk '{print $5}' | head -1)
          if [ -z "$FIRMWARE_SIZE" ]; then
            FIRMWARE_SIZE=$(ls -lh *.bin 2>/dev/null | awk '{print $5}' | head -1)
          fi
          
          echo "FIRMWARE=$PWD" >> $GITHUB_ENV
          echo "FIRMWARE_SIZE=$FIRMWARE_SIZE" >> $GITHUB_ENV
          echo "status=success" >> $GITHUB_OUTPUT
          echo "✅ 固件整理完成，大小: $FIRMWARE_SIZE"

      - name: 📤 上传固件到Artifacts
        uses: actions/upload-artifact@v4
        if: steps.organize.outputs.status == 'success' && env.UPLOAD_FIRMWARE == 'true' && !cancelled()
        with:
          name: OpenWrt_firmware_${{ needs.prepare.outputs.build_tag }}
          path: ${{ env.FIRMWARE }}

      - name: 🏷️ 生成发布标签
        id: tag
        if: env.UPLOAD_RELEASE == 'true' && steps.organize.outputs.status == 'success' && !cancelled()
        run: |
          echo "release_tag=${{ needs.prepare.outputs.build_tag }}" >> $GITHUB_OUTPUT
          echo "✅ 发布标签: ${{ needs.prepare.outputs.build_tag }}"

      - name: 📋 生成发布说明
        if: env.UPLOAD_RELEASE == 'true' && steps.organize.outputs.status == 'success' && !cancelled()
        run: |
          echo "# 🛠️ OpenWrt智能编译固件" > release.md
          echo "" >> release.md
          echo "## 📋 固件信息" >> release.md
          echo "- **源码**: ${{ needs.prepare.outputs.source_name }} (${{ needs.prepare.outputs.source_branch }})" >> release.md
          echo "- **设备**: ${{ needs.prepare.outputs.device_name }} (${{ needs.prepare.outputs.target_device }})" >> release.md
          echo "- **架构**: ${{ needs.prepare.outputs.device_target }}" >> release.md
          echo "- **大小**: ${{ env.FIRMWARE_SIZE }}" >> release.md
          echo "- **编译时间**: $(date '+%Y-%m-%d %H:%M:%S')" >> release.md
          echo "- **编译描述**: ${{ needs.prepare.outputs.build_description }}" >> release.md
          echo "" >> release.md
          
          if [ -n "${{ needs.prepare.outputs.plugins_list }}" ]; then
            echo "## 🔧 包含的插件" >> release.md
            IFS=',' read -ra PLUGINS <<< "${{ needs.prepare.outputs.plugins_list }}"
            for plugin in "${PLUGINS[@]}"; do
              echo "- ✅ $plugin" >> release.md
            done
          else
            echo "## 🔧 插件" >> release.md
            echo "使用源码默认插件配置" >> release.md
          fi
          
          echo "" >> release.md
          echo "## 📥 下载说明" >> release.md
          echo "1. 根据设备型号选择对应的固件文件" >> release.md
          echo "2. 刷写前请备份原有配置" >> release.md
          echo "3. 首次刷入建议不保留配置" >> release.md
          echo "" >> release.md
          echo "## ⚠️ 注意事项" >> release.md
          echo "- 刷机有风险，请谨慎操作" >> release.md
          echo "- 确保设备型号匹配" >> release.md
          echo "- 建议先在恢复模式下刷入" >> release.md

      - name: 📤 上传固件到Release
        uses: softprops/action-gh-release@v2
        if: env.UPLOAD_RELEASE == 'true' && steps.organize.outputs.status == 'success' && !cancelled()
        with:
          tag_name: ${{ steps.tag.outputs.release_tag }}
          body_path: release.md
          files: ${{ env.FIRMWARE }}/*

      - name: 📊 生成编译总结
        if: steps.organize.outputs.status == 'success' && !cancelled()
        run: |
          echo "🎉 编译成功完成！"
          echo ""
          echo "📦 固件信息:"
          echo "  源码: ${{ needs.prepare.outputs.source_name }}"
          echo "  设备: ${{ needs.prepare.outputs.device_name }}"
          echo "  大小: ${{ env.FIRMWARE_SIZE }}"
          echo "  标签: ${{ needs.prepare.outputs.build_tag }}"
          echo ""
          echo "🔗 下载链接:"
          echo "  Artifacts: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo "  Releases: https://github.com/${{ github.repository }}/releases/tag/${{ steps.tag.outputs.release_tag }}"

      - name: 🧹 清理工作空间
        if: always()
        run: |
          cd /workdir
          rm -rf openwrt
          echo "✅ 工作空间清理完成"